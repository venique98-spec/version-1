{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # ukids_scheduler_app.py\
# Streamlit uKids scheduler with Director/Leader rules, extra-pass rows,\
# robust CSV ingestion, and Excel export.\
\
import io\
import re\
import base64\
from collections import defaultdict, Counter\
from datetime import datetime, date\
\
import numpy as np\
import pandas as pd\
import streamlit as st\
from openpyxl import Workbook\
from openpyxl.utils import get_column_letter\
\
st.set_page_config(page_title="uKids Scheduler", layout="wide")\
st.title("uKids Scheduler")\
\
st.markdown(\
    """\
    <style>\
      .stApp \{ background: #000; color: #fff; \}\
      .stButton>button, .stDownloadButton>button \{ background:#444; color:#fff; \}\
      .stDataFrame \{ background:#111; \}\
      .stAlert \{ color:#111; \}\
    </style>\
    """,\
    unsafe_allow_html=True,\
)\
\
# Optional logo (ignore if missing)\
for logo_name in ["image(1).png", "image.png", "logo.png"]:\
    try:\
        with open(logo_name, "rb") as img_file:\
            encoded = base64.b64encode(img_file.read()).decode()\
            st.markdown(\
                f"<div style='text-align:center'><img src='data:image/png;base64,\{encoded\}' width='520'></div>",\
                unsafe_allow_html=True,\
            )\
            break\
    except Exception:\
        pass\
\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
# Helpers\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
MONTH_ALIASES = \{\
    "jan": 1, "january": 1,\
    "feb": 2, "february": 2,\
    "mar": 3, "march": 3,\
    "apr": 4, "april": 4,\
    "may": 5,\
    "jun": 6, "june": 6,\
    "jul": 7, "july": 7,\
    "aug": 8, "august": 8,\
    "sep": 9, "sept": 9, "september": 9,\
    "oct": 10, "october": 10,\
    "nov": 11, "november": 11,\
    "dec": 12, "december": 12,\
\}\
YES_SET = \{"yes", "y", "true", "available"\}\
\
def read_csv_robust(uploaded_file, label_for_error):\
    """Read a Streamlit UploadedFile into a DataFrame, trying multiple encodings and separators."""\
    raw = uploaded_file.getvalue()\
    encodings = ["utf-8", "utf-8-sig", "cp1252", "iso-8859-1"]\
    seps = [None, ",", ";", "\\t", "|"]\
\
    last_err = None\
    for enc in encodings:\
        for sep in seps:\
            try:\
                df = pd.read_csv(io.BytesIO(raw), encoding=enc, engine="python", sep=sep)\
                if df.shape[1] == 0:\
                    raise ValueError("Parsed 0 columns.")\
                return df\
            except Exception as e:\
                last_err = f"\{type(e).__name__\}: \{e\}"\
                continue\
    st.error(\
        f"Could not read \{label_for_error\} CSV. Last error: \{last_err\}. "\
        "Try re-exporting as CSV (UTF-8) or remove unusual characters in headers."\
    )\
    st.stop()\
\
def detect_name_column(df: pd.DataFrame, fallback_first: bool = True) -> str:\
    candidates = [\
        "What is your name AND surname?",\
        "What is your name and surname?",\
        "Name",\
        "Full name",\
        "Full names",\
    ]\
    cols_l = \{str(c).strip().lower(): c for c in df.columns\}\
    for c in candidates:\
        key = c.strip().lower()\
        if key in cols_l:\
            return cols_l[key]\
    for c in df.columns:\
        if isinstance(c, str) and "name" in c.lower():\
            return c\
    if fallback_first:\
        return df.columns[0]\
    raise ValueError("Could not detect a 'name' column.")\
\
def normalize(s: str) -> str:\
    return re.sub(r"[^a-z0-9]+", " ", str(s).lower()).strip()\
\
def is_priority_col(series: pd.Series) -> bool:\
    vals = pd.to_numeric(series, errors="coerce").dropna()\
    if len(vals) == 0:\
        return False\
    return (vals.min() >= 0) and (vals.max() <= 5)\
\
def parse_month_and_dates_from_headers(responses_df: pd.DataFrame):\
    avail_cols = [c for c in responses_df.columns if isinstance(c, str) and c.strip().lower().startswith("are you available")]\
    if not avail_cols:\
        avail_cols = [\
            c for c in responses_df.columns\
            if isinstance(c, str)\
            and re.search(r"\\b\\d\{1,2\}\\b", c.lower())\
            and any(m in c.lower() for m in MONTH_ALIASES)\
        ]\
    if not avail_cols:\
        raise ValueError("No availability columns found. Expect headings like 'Are you available 7 September?'")\
\
    info = []\
    for c in avail_cols:\
        low = c.lower()\
        mname = None\
        for alias in MONTH_ALIASES:\
            if alias in low:\
                mname = alias\
                break\
        day_m = re.search(r"\\b(\\d\{1,2\})\\b", low)\
        if mname and day_m:\
            info.append((c, MONTH_ALIASES[mname], int(day_m.group(1))))\
    if not info:\
        raise ValueError("Could not parse day/month from availability headers.")\
\
    months = \{m for _, m, _ in info\}\
    if len(months) > 1:\
        raise ValueError(f"Multiple months detected in availability headers: \{sorted(months)\}. Upload one month at a time.")\
    month = months.pop()\
\
    if "Timestamp" in responses_df.columns:\
        years = pd.to_datetime(responses_df["Timestamp"], errors="coerce").dt.year.dropna().astype(int)\
        year = int(years.mode().iloc[0]) if not years.empty else date.today().year\
    else:\
        year = date.today().year\
\
    date_map = \{c: pd.Timestamp(datetime(year, month, d)).normalize() for c, _, d in info\}\
    service_dates = sorted(set(date_map.values()))\
    sheet_name = f"\{pd.Timestamp(year=year, month=month, day=1):%B %Y\}"\
    return year, month, date_map, service_dates, sheet_name\
\
def build_long_df(people_df: pd.DataFrame, name_col: str, role_cols, codes_col: str = None):\
    """\
    returns:\
      - long_df with columns [person, role, priority]\
      - role_codes flags per person: has_D / has_BL / has_PL / has_EL / has_SL + raw_codes\
    """\
    records = []\
    role_codes = \{\}\
    for _, r in people_df.iterrows():\
        person = str(r[name_col]).strip()\
        if not person or person.lower() == "nan":\
            continue\
\
        # parse codes (2nd column)\
        flags = \{"has_D": False, "has_BL": False, "has_PL": False, "has_EL": False, "has_SL": False, "raw": ""\}\
        if codes_col and codes_col in people_df.columns:\
            raw = str(r.get(codes_col, "") or "")\
            flags["raw"] = raw\
            toks = re.findall(r"[A-Za-z]+", raw.upper())\
            for t in toks:\
                if t == "D":\
                    flags["has_D"] = True\
                elif t == "BL":\
                    flags["has_BL"] = True\
                elif t == "PL":\
                    flags["has_PL"] = True\
                elif t == "EL":\
                    flags["has_EL"] = True\
                elif t == "SL":\
                    flags["has_SL"] = True\
        role_codes[person] = flags\
\
        for role in role_cols:\
            pr = pd.to_numeric(r[role], errors="coerce")\
            if pd.isna(pr):\
                continue\
            pr = int(round(pr))\
            if pr >= 1:\
                # If Director: only eligible for priority==1 roles\
                if flags["has_D"] and pr != 1:\
                    continue\
                records.append(\{"person": person, "role": role, "priority": pr\})\
    return pd.DataFrame(records), role_codes\
\
def parse_availability(responses_df: pd.DataFrame, name_col_resp: str, date_map):\
    availability = \{\}\
    yes_counts = Counter()\
    for _, row in responses_df.iterrows():\
        nm = str(row.get(name_col_resp, "")).strip()\
        if not nm or nm.lower() == "nan":\
            continue\
        availability.setdefault(nm, \{\})\
        for col, dt in date_map.items():\
            ans = str(row.get(col, "")).strip().lower()\
            is_yes = ans in YES_SET\
            availability[nm][dt] = is_yes\
            if is_yes:\
                yes_counts[nm] += 1\
    few_yes = sorted([n for n, c in yes_counts.items() if c < 2])\
    service_dates = sorted(set(date_map.values()))\
    return availability, service_dates, few_yes\
\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
# Slot plan (leaders included) \'97 every slot becomes its own row\
# Plus extra rows (Group A/B) with special rules.\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
EXTRA_GROUP_A_ROWS = [\
    "Info 1", "Info 2", "Info 3", "Info 4",\
    "uKids Setup 1", "uKids Setup 2", "uKids Setup 3", "uKids Setup 4",\
]\
\
EXTRA_GROUP_B_ROWS = [\
    "Outside assistant 1", "Outside assistant 2",\
    "Helping Ninja & Check in (Only uKids Leaders)",\
    "Helping Ninja 1", "Helping Ninja 2",\
    "uKids Hall 1", "uKids Hall 2", "uKids Hall 3", "uKids Hall 4",\
]\
\
def build_slot_plan():\
    return \{\
        # Age 1\
        "Age 1 leader": 1,\
        "Age 1 classroom": 5,        # #5 is gated by D leader present\
        "Age 1 nappies": 1,\
        "Age 1 bags girls": 1,\
        "Age 1 bags boys": 1,\
        # Age 2\
        "Age 2 leader": 1,\
        "Age 2 classroom": 4,\
        "Age 2 nappies": 1,\
        "Age 2 bags girls": 1,\
        "Age 2 bags boys": 1,\
        # Age 3\
        "Age 3 leader": 1,\
        "Age 3 classroom": 4,\
        "Age 3 bags": 1,\
        # Age 4\
        "Age 4 leader": 1,\
        "Age 4 classroom": 4,\
        # Age 5\
        "Age 5 leader": 1,\
        "Age 5 classroom": 3,\
        # Age 6\
        "Age 6 leader": 1,\
        "Age 6 classroom": 3,\
        # Age 7\
        "Age 7 leader": 1,\
        "Age 7 classroom": 2,\
        # Age 8\
        "Age 8 leader": 1,\
        "Age 8 classroom": 2,\
        # Age 9 (single classroom, per your spec)\
        "Age 9 leader": 1,\
        "Age 9 classroom": 1,\
        # Age 10\
        "Age 10 leader": 1,\
        "Age 10 classroom": 1,\
        # Age 11\
        "Age 11 leader": 1,\
        "Age 11 classroom": 1,\
        # Special Needs\
        "Special needs leader": 1,\
        "Special needs classroom": 2,\
        # Group A (each capacity 1)\
        **\{r: 1 for r in EXTRA_GROUP_A_ROWS\},\
        # Group B (each capacity 1)\
        **\{r: 1 for r in EXTRA_GROUP_B_ROWS\},\
    \}\
\
def expand_roles_to_slots(slot_plan):\
    slot_rows = []\
    slot_index = \{\}\
    for role, n in slot_plan.items():\
        if n <= 0:\
            continue\
        if n == 1:\
            lab = role\
            slot_rows.append(lab)\
            slot_index[lab] = role\
        else:\
            for i in range(1, n + 1):\
                lab = f"\{role\} #\{i\}"\
                slot_rows.append(lab)\
                slot_index[lab] = role\
    return slot_rows, slot_index\
\
def build_priority_lookup(long_df):\
    lut = \{\}\
    for _, r in long_df.iterrows():\
        lut[(str(r["person"]).strip(), str(r["role"]).strip())] = int(r["priority"])\
    return lut\
\
def served_in_priority_one(assignments_by_cell, priority_lut, slot_to_role):\
    """\
    Find people who were assigned to any slot whose *base role* they have priority==1 for.\
    Example: "Age 2 classroom #3" \uc0\u8594  base role "Age 2 classroom"\
    """\
    served = set()\
    for (row_name, _d), names in assignments_by_cell.items():\
        base_role = slot_to_role.get(row_name, row_name)\
        for nm in names:\
            if priority_lut.get((nm, base_role)) == 1:\
                served.add(nm)\
    return served\
\
def is_ukids_leader(flags: dict) -> bool:\
    return bool(flags.get("has_BL") or flags.get("has_PL") or flags.get("has_EL") or flags.get("has_SL") or flags.get("has_D"))\
\
def base_max_for_person(flags: dict) -> int:\
    return 1 if flags.get("has_D", False) else 2\
\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
# Core scheduling (main pass) \'97 fill leaders & classrooms etc. within base caps\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
def build_eligibility(long_df: pd.DataFrame):\
    # set of roles per person\
    elig = defaultdict(set)\
    for _, r in long_df.iterrows():\
        elig[str(r["person"]).strip()].add(str(r["role"]).strip())\
    return elig\
\
def main_pass_schedule(long_df, availability, service_dates, role_codes):\
    slot_plan = build_slot_plan()\
    slot_rows, slot_to_role = expand_roles_to_slots(slot_plan)\
    eligibility = build_eligibility(long_df)\
\
    # Only schedule people in both sources\
    people = sorted(set(eligibility.keys()) & set(availability.keys()))\
\
    # storage: \{(row_name, date): [names]\}\
    schedule_cells = \{(slot, d): [] for slot in slot_rows for d in service_dates\}\
    assign_count = defaultdict(int)\
\
    # Helper to check if a slot is the "classroom #5" of an age with the D-gate\
    def is_gated_classroom_5(slot_name: str):\
        return slot_name in \{"Age 1 classroom #5"\}\
\
    def leader_for_age_on_date(age_prefix: str, d):\
        # find leader row value on date d\
        key = (f"\{age_prefix\} leader", d)\
        names = schedule_cells.get(key, [])\
        return names[0] if names else None\
\
    # Order slots so leaders come before classrooms (so the D-gate can work)\
    def slot_sort_key(s):\
        if "leader" in s:\
            return (0, s)\
        if "classroom" in s:\
            return (1, s)\
        return (2, s)\
    slot_rows_sorted = sorted(slot_rows, key=slot_sort_key)\
\
    for d in service_dates:\
        assigned_today = set()\
        for slot_row in slot_rows_sorted:\
            base_role = slot_to_role[slot_row]\
\
            # D-gate for "Age 1 classroom #5"\
            if is_gated_classroom_5(slot_row):\
                # need a Director as the leader for Age 1 that date\
                leader = leader_for_age_on_date("Age 1", d)\
                if not leader or not role_codes.get(leader, \{\}).get("has_D", False):\
                    continue  # skip filling this slot\
\
            # build candidate list\
            cands = []\
            for p in people:\
                flags = role_codes.get(p, \{\})\
                # cap by base role (D:1, others:2)\
                if assign_count[p] >= base_max_for_person(flags):\
                    continue\
                # not double-booked on same date\
                if p in assigned_today:\
                    continue\
                # available?\
                if not availability.get(p, \{\}).get(d, False):\
                    continue\
                # eligible for this role? (exact or normalized match)\
                elig_roles = eligibility.get(p, set())\
                ok = False\
                if base_role in elig_roles:\
                    ok = True\
                else:\
                    nb = normalize(base_role)\
                    for er in elig_roles:\
                        if normalize(er) == nb:\
                            ok = True\
                            break\
                if ok:\
                    cands.append(p)\
\
            if cands:\
                cands.sort(key=lambda name: assign_count[name])\
                chosen = cands[0]\
                schedule_cells[(slot_row, d)].append(chosen)\
                assign_count[chosen] += 1\
                assigned_today.add(chosen)\
\
    return schedule_cells, assign_count, slot_rows, slot_to_role\
\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
# Post Passes\
#   A) Allow +1 cap ONLY in Group A rows (Info / Setup)\
#   B) Fill Group B rows only with people who served in a #1 role (no cap raise)\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
def assign_extra_group_a(service_dates, schedule_cells, assign_count, availability, role_codes):\
    for d in service_dates:\
        assigned_today = set(nm for (rn, dd), names in schedule_cells.items() if dd == d for nm in names)\
        for row_name in EXTRA_GROUP_A_ROWS:\
            key = (row_name, d)\
            if len(schedule_cells[key]) >= 1:\
                continue\
            # candidates: available, not assigned today, under (base+1)\
            cands = []\
            for p in availability.keys():\
                if not availability.get(p, \{\}).get(d, False):\
                    continue\
                if p in assigned_today:\
                    continue\
                flags = role_codes.get(p, \{\})\
                base = base_max_for_person(flags)\
                if assign_count.get(p, 0) >= base + 1:\
                    continue\
                cands.append(p)\
            cands.sort(key=lambda nm: assign_count.get(nm, 0))\
            if cands:\
                chosen = cands[0]\
                schedule_cells[key].append(chosen)\
                assign_count[chosen] = assign_count.get(chosen, 0) + 1\
\
def assign_extra_group_b(service_dates, schedule_cells, assign_count, availability, role_codes, served_p1_people):\
    for d in service_dates:\
        assigned_today = set(nm for (rn, dd), names in schedule_cells.items() if dd == d for nm in names)\
        for row_name in EXTRA_GROUP_B_ROWS:\
            key = (row_name, d)\
            if len(schedule_cells[key]) >= 1:\
                continue\
\
            cands = []\
            for p in availability.keys():\
                if p not in served_p1_people:\
                    continue\
                if not availability.get(p, \{\}).get(d, False):\
                    continue\
                if p in assigned_today:\
                    continue\
                flags = role_codes.get(p, \{\})\
                base = base_max_for_person(flags)\
                if assign_count.get(p, 0) >= base:\
                    continue\
                # special gate: Only uKids Leaders for the combined role\
                if "Helping Ninja & Check in" in row_name and not is_ukids_leader(flags):\
                    continue\
                cands.append(p)\
\
            cands.sort(key=lambda nm: assign_count.get(nm, 0))\
            if cands:\
                chosen = cands[0]\
                schedule_cells[key].append(chosen)\
                assign_count[chosen] = assign_count.get(chosen, 0) + 1\
\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
# Export helpers\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
def excel_autofit(ws):\
    for col_idx, column_cells in enumerate(\
        ws.iter_cols(min_row=1, max_row=ws.max_row, min_col=1, max_col=ws.max_column), start=1\
    ):\
        max_len = 0\
        for cell in column_cells:\
            val = "" if cell.value is None else str(cell.value)\
            max_len = max(max_len, len(val))\
        ws.column_dimensions[get_column_letter(col_idx)].width = min(max(12, max_len + 2), 80)\
\
def build_schedule_df(schedule_cells, slot_rows, service_dates):\
    cols = [d.strftime("%Y-%m-%d") for d in service_dates]\
    schedule_df = pd.DataFrame(index=slot_rows, columns=cols)\
    for (slot_row, d), names in schedule_cells.items():\
        schedule_df.loc[slot_row, d.strftime("%Y-%m-%d")] = ", ".join(names)\
    return schedule_df.fillna("")\
\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
# UI\
# \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \
st.subheader("1) Upload files (CSV \'97 any filename)")\
c1, c2 = st.columns(2)\
with c1:\
    positions_file = st.file_uploader("Serving positions (CSV)", type=["csv"], key="positions_csv_any")\
with c2:\
    responses_file = st.file_uploader("Availability responses (CSV)", type=["csv"], key="responses_csv_any")\
\
st.caption("\'95 Positions CSV: first col = volunteer names; second col = role codes (e.g., D/BL/PL/EL/SL), other cols = roles with values 0\'965 (0 = not eligible).")\
st.caption("\'95 Responses CSV: includes a name column and columns like 'Are you available 7 September?'.")\
\
if st.button("Generate Schedule", type="primary"):\
    if not positions_file or not responses_file:\
        st.error("Please upload both CSV files.")\
        st.stop()\
\
    positions_df = read_csv_robust(positions_file, "positions")\
    responses_df = read_csv_robust(responses_file, "responses")\
\
    # Detect name columns\
    try:\
        name_col_positions = positions_df.columns[0]  # first column is full names\
    except Exception as e:\
        st.error(f"Could not detect a name column in positions CSV: \{e\}")\
        st.stop()\
\
    try:\
        name_col_responses = detect_name_column(responses_df, fallback_first=False)\
    except Exception as e:\
        st.error(f"Could not detect a name column in responses CSV: \{e\}")\
        st.stop()\
\
    # Codes column (second column)\
    codes_col = None\
    if positions_df.shape[1] >= 2:\
        codes_col = positions_df.columns[1]\
\
    # Ensure name columns are strings\
    positions_df[name_col_positions] = positions_df[name_col_positions].astype(str)\
    responses_df[name_col_responses] = responses_df[name_col_responses].astype(str)\
\
    # Role columns (from third column onward)\
    role_cols = [c for c in positions_df.columns[2:] if is_priority_col(positions_df[c])]\
    if not role_cols:\
        st.error("No role columns with priorities (0..5) detected in the positions CSV (from third column onwards).")\
        st.stop()\
\
    # Build eligibility (+ role code flags)\
    long_df, role_codes = build_long_df(positions_df, name_col_positions, role_cols, codes_col=codes_col)\
    if long_df.empty:\
        st.error("No eligible assignments found (after applying Director=1-only rule and removing 0s).")\
        st.stop()\
\
    # Parse dates\
    try:\
        year, month, date_map, service_dates, sheet_name = parse_month_and_dates_from_headers(responses_df)\
    except Exception as e:\
        st.error(f"Could not parse month & dates from responses: \{e\}")\
        st.stop()\
\
    # Availability & <2-Yes list (INFO ONLY \'97 not excluded)\
    availability, service_dates, few_yes_list = parse_availability(responses_df, name_col_responses, date_map)\
\
    # MAIN PASS\
    schedule_cells, assign_count, slot_rows, slot_to_role = main_pass_schedule(\
        long_df, availability, service_dates, role_codes\
    )\
\
    # Build a proper (person, base_role) -> priority lookup\
    priority_lut = build_priority_lookup(long_df)\
\
    # People who served in a priority==1 base role (slot names mapped to base roles)\
    served_p1_people = served_in_priority_one(schedule_cells, priority_lut, slot_to_role)\
\
    # PASS A: allow +1 cap (non-D to 3, D to 2) but ONLY for Group A rows\
    assign_extra_group_a(service_dates, schedule_cells, assign_count, availability, role_codes)\
\
    # PASS B: fill Group B only if already served in a #1 role (no cap raise)\
    assign_extra_group_b(service_dates, schedule_cells, assign_count, availability, role_codes, served_p1_people)\
\
    # Build schedule DataFrame\
    schedule_df = build_schedule_df(schedule_cells, slot_rows, service_dates)\
\
    # Stats\
    total_slots = schedule_df.size\
    filled_slots = int((schedule_df != "").sum().sum())\
    fill_rate = (filled_slots / total_slots) if total_slots else 0.0\
    unfilled = total_slots - filled_slots\
    per_person = (\
        pd.Series(assign_count, name="Assignments")\
        .sort_values(ascending=False)\
        .reset_index()\
        .rename(columns=\{"index": "Person"\})\
    )\
\
    st.success(f"Schedule generated for **\{sheet_name\}**")\
    st.write(f"Filled slots: **\{filled_slots\} / \{total_slots\}**  (Fill rate: **\{fill_rate:.1%\}**)  \'95  Unfilled: **\{unfilled\}**")\
\
    st.subheader("Schedule (each slot is its own row)")\
    st.dataframe(schedule_df, use_container_width=True)\
\
    st.subheader("Assignment Summary")\
    st.dataframe(per_person, use_container_width=True)\
\
    st.subheader("People with < 2 'Yes' dates (for reference only)")\
    few_yes_df = pd.DataFrame(\{"Person": few_yes_list\})\
    st.dataframe(few_yes_df, use_container_width=True)\
\
    # Excel output\
    wb = Workbook()\
    ws = wb.active\
    ws.title = sheet_name\
\
    header = ["Position / Slot"] + [d.strftime("%Y-%m-%d") for d in service_dates]\
    ws.append(header)\
    for row_name in slot_rows:\
        row_vals = [row_name] + [", ".join(schedule_cells[(row_name, d)]) for d in service_dates]\
        ws.append(row_vals)\
    excel_autofit(ws)\
\
    if few_yes_list:\
        ws2 = wb.create_sheet("Fewer than 2 Yes (info)")\
        ws2.append(["Person"])\
        for p in few_yes_list:\
            ws2.append([p])\
        excel_autofit(ws2)\
\
    ws3 = wb.create_sheet("Assignment Summary")\
    ws3.append(["Person", "Assignments"])\
    for _, r in per_person.iterrows():\
        ws3.append([r["Person"], int(r["Assignments"])])\
    excel_autofit(ws3)\
\
    buf = io.BytesIO()\
    wb.save(buf)\
    buf.seek(0)\
    st.download_button(\
        "Download Excel (.xlsx)",\
        data=buf,\
        file_name=f"uKids_schedule_\{sheet_name.replace(' ','_')\}.xlsx",\
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",\
    )\
else:\
    st.info("Upload the two CSV files (any names), then click **Generate Schedule**.")\
}